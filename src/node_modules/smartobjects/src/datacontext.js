"use strict";

var _ = require('lodash');
var EventEmitter = require('micro-events');
var Check = require("./check.js");
var Errors = require("./errors.js");
var Command = require("./command.js");

export default class DataContext extends EventEmitter {

    /**
     * Create empty data context object.
     */
    constructor() {
        super();
        this._errors = new Errors();
        this._validating = false;
    }

    /**
     * Fire property change event
     * @param name
     * @param newValue
     * @param oldValue
     * @returns {*}
     */
    firePropertyChange(name, newValue, oldValue) {
        if (!this._validating)
            this.emit(name, newValue, name, oldValue);
    }

    /**
     * Clear all data context writable properties and set properties specified by newData
     * @param newData
     */
    reset(newData) {
        if (!newData) newData = {};
        _.each(this.properties(), (property, name)=> {
            if (property.writable) {
                this[name] = newData[name] || property.default;
            }
        });
    }

    /**
     * Fill writable properties from new data. If value is not found in newData then it is left as is.
     * @param newData
     */
    putAll(newData) {
        if (!newData) return;
        _.each(this.properties(), (property, name)=> {
            if (property.writable && newData.hasOwnProperty(name)) {
                this[name] = newData[name];
            }
        });
    }

    /**
     * Return array of errors for given key. If key is not given return all errors.
     * @param key
     * @returns {*}
     */
    errors(key) {
        return _.map(this._errors.errors(key), (error)=> {
            return error.toString();
        });
    }

    /**
     * True if data context has errors for a given key
     * @param key
     * @returns {*}
     */
    hasErrors(key) {
        return this._errors.hasErrors(key);
    }

    /**
     * true if data context does not have any errors
     * @param key
     * @returns {*}
     */
    isValid(key) {
        return this._errors.isValid(key);
    }

    /**
     * Return 'checker' object which add errors to this data context.
     * @param key
     * @param value
     * @returns {*}
     */
    check(key, value) {
        return this._errors.check(key, value);
    }

    /**
     * Clear errors in this data context. If key is not given then clear all errors.
     * @param key
     */
    clearErrors(key) {
        this._errors.clear(key);
    }

    /**
     * Return array data context property descriptors.
     */
    properties() {
        return this.constructor.properties();
    }

    /**
     * Return data context property descriptor
     * @param name
     */
    property(name) {
        return this.constructor.property(name);
    }

    /**
     * Run all setters in data context which in turn trigger their validation
     * @returns {*}
     */
    validate() {
        try {
            this._validating = true;
            _.each(this.properties(), (property, name)=> {
                var descriptor = this.property(name);
                if (descriptor && descriptor.writable) {
                    this[name] = this[name];
                }
            });
        } finally {
            this._validating = false;
            _.each(this.properties(), (property, name)=> {
                if (this.errors(name).length > 0) {
                    var val = this[name];
                    return this.firePropertyChange(name, val, val);
                }
            });
        }
        return this.isValid();
    }

    validating() {
        return this._validating;
    }

    /**
     * Attach event listener to all property change events in this data context.
     * When property changed 'update' callback receive object generated by propertyState.
     * @param update {Function} function (newValue, propertyName, oldValue)
     * @returns {Function} listener object
     */
    attach(update) {
        _.each(this.properties(), (property, name) => {
            this.on(name, update);
        });
        return update;
    }

    /**
     * Detach event listener previousl attached by 'attach'
     * @param listener
     */
    detach(listener) {
        _.each(this.properties(), (property, name)=> {
            this.off(name, listener);
        });
    }

    /**
     * @return all commands which are running at the moment
     */
    runningCommands() {
        return _(this.properties())
            .map((property, name) => {
                if (property.command && this[name].isRunning) {
                    return this[name];
                }
            })
            .compact().values();
    }
}


/**
 * Generate function named 'name' which can be used to get/set object property
 * When property is set, an event with same name is fired.
 * Properties could be:
 * 1. RW property MyObject.property('p', { get: function () {}, set: function () {} })
 * 2. RO property MyObject.property('p', { get: function () {} })
 * 3. Default RW property MyObject.property('p', {}); Trivial getter and setter are generated.
 */
DataContext.property = function (name, definition) {

    var properties;
    if (!definition) {
        var prototype = this.prototype;
        while (prototype != null) {
            if (prototype.constructor && prototype.constructor.dataContext$properties) {
                properties = prototype.constructor.dataContext$properties;
                if (properties[name]) return properties[name];
            }
            prototype = Object.getPrototypeOf(prototype);
        }
    } else {
        if (!this.hasOwnProperty('dataContext$properties')) {
            Object.defineProperty(this, "dataContext$properties", {
                configurable: false,
                enumerable: false,
                value: {}
            });
        }

        properties = this.dataContext$properties;
        if (!_.isObject(definition)) throw new Error("Property definition should be an object.");

        _.defaults(definition, {
            resettable: true,
            name: name
        });

        properties[name] = definition;

        if (definition.get && definition.set) {
            definition.writable = true;
            Object.defineProperty(this.prototype, name, makeRWProperty(name, definition));
        } else if (definition.get) {
            definition.writable = false;
            Object.defineProperty(this.prototype, name, makeReadonlyProperty(name, definition));
        } else {
            definition.writable = true;
            Object.defineProperty(this.prototype, name, makeDefaultRWProperty(name, definition));
        }
    }
};

var firePropertyChange = function (model, name, newValue, oldValue) {
    if (oldValue !== newValue) {
        return model.firePropertyChange(name, newValue, oldValue);
    }
};

var makeReadonlyProperty = function (name, property) {
    return {
        get() {
            var value = property.get.call(this);
            return _.isUndefined(value) ? property.default : value;
        },
        enumerable: true,
        configurable: true
    }
};

var makeRWProperty = function (name, property) {
    return {
        get () {
            var value = property.get.call(this);
            return _.isUndefined(value) ? property.default : value;
        },
        set(newValue){
            var oldValue = property.get.call(this);
            property.set.call(this, newValue);
            firePropertyChange(this, name, newValue, oldValue);
        },
        enumerable: true,
        configurable: true
    };
};

var makeDefaultRWProperty = function (name, property) {
    var ivar = "_" + name;
    return {
        get() {
            var value = this[ivar];
            return _.isUndefined(value) ? property.default : value;
        },
        set(newValue) {
            var oldValue = this[ivar];
            this[ivar] = newValue;
            firePropertyChange(this, name, newValue, oldValue);
        },
        enumerable: true,
        configurable: true
    }
};

/**
 * Generate readonly command property. Such property hold instance of command.
 * When command is executed an event named as property is fired.
 * Ex: MyObject.command('loadSome', {
 * execute: function () { ... },
 * canExecute: function () { ... }
 * });

 * Property definition passed to DataContext.command passed thru to Command object as is.
 * See Command documentation for details.

 * You can override commands in sub classes. Ex:
 * class Subclass extends MyObject {}
 * Subclass.command('loadSome', { debounce: { timeout: 1000 } });
 */
DataContext.command = function (name, config) {
    var ivar = "_" + name;
    var property = this.property(name);
    if (property) {
        if (!property.command)
            throw new Error("Cannot override regular property with command");
        config = _.extend({}, property.command, config);
    }

    this.property(name, {
        command: config,
        writable: false,
        get: function () {
            var cmd = this[ivar];
            if (!cmd) {
                cmd = this[ivar] = new Command(config, this);
                cmd.name = name;
                cmd.on('execute', ()=> {
                    this.firePropertyChange(name, cmd, cmd);
                });
            }
            return this[ivar];
        }
    });
};

/*
 Helper method to generate command and property definitions.

 Command is generated if params has 'execute' property, otherwise property is generated.

 See methods 'DataContext.property' and 'DataContext.command' above for details.
 */
DataContext.properties = function (params) {
    if (!params) {
        var result = {};
        var prototype = this.prototype;
        while (prototype != null) {
            if (prototype.constructor && prototype.constructor.dataContext$properties) {
                var properties = prototype.constructor.dataContext$properties;
                _.defaults(result, properties);
            }
            prototype = Object.getPrototypeOf(prototype);
        }
        return result;
    } else {
        for (var property in params) {
            if (params.hasOwnProperty(property)) {
                var definition = params[property];
                var existingProperty = this.property(property);
                if (existingProperty) {
                    if (existingProperty.command) {
                        this.command(property, definition);
                    } else {
                        this.property(property, definition);
                    }
                } else {
                    if (definition.execute) {
                        this.command(property, definition);
                    } else {
                        this.property(property, definition);
                    }
                }
            }
        }
    }
};